-- Show that create_timeseries_table only works for empty range partitioned tables
-- 1) Unpartitioned tables are not supported
CREATE TABLE unpartitioned_table(
    measureid integer,
    eventdatetime date,
    measure_data integer);
SELECT create_timeseries_table('unpartitioned_table', INTERVAL '1 day');
ERROR:  table must be partitioned by range to convert it to timeseries table
DROP TABLE unpartitioned_table;
-- 2) Nonempty tables are not supported
CREATE TABLE nonempty_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate);
CREATE TABLE nonempty_partitioned_table_2021_2100 PARTITION OF nonempty_partitioned_table FOR VALUES FROM ('2021-01-01') TO ('2100-01-01');
INSERT INTO nonempty_partitioned_table VALUES (1, now(), 1);
SELECT create_timeseries_table('nonempty_partitioned_table', INTERVAL '1 year');
ERROR:  table must be empty to convert it to timeseries table
DROP TABLE nonempty_partitioned_table;
-- 3) Table must be partitioned on single column
CREATE TABLE multicolumn_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate, measureid);
SELECT create_timeseries_table('multicolumn_partitioned_table', INTERVAL '1 year');
ERROR:  table must be partitioned by single column to convert it to timeseries table
DROP TABLE multicolumn_partitioned_table;
-- 4) Table must be partitioned by range
CREATE TABLE list_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY LIST(eventdate);
SELECT create_timeseries_table('list_partitioned_table', INTERVAL '1 year');
ERROR:  table must be partitioned by range to convert it to timeseries table
DROP TABLE list_partitioned_table;
CREATE TABLE hash_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY HASH(eventdate);
SELECT create_timeseries_table('hash_partitioned_table', INTERVAL '1 year');
ERROR:  table must be partitioned by range to convert it to timeseries table
DROP TABLE hash_partitioned_table;
-- Show that partition column type, partition interval and thresholds must align
-- 1) Partition interval must be multiple days for date partitioned tables
CREATE TABLE date_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate);
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '15 minutes');
ERROR:  partition interval for table partitioned on date must be multiple days
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '3 hours');
ERROR:  partition interval for table partitioned on date must be multiple days
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 day 15 minutes');
ERROR:  partition interval for table partitioned on date must be multiple days
BEGIN;
    SELECT create_timeseries_table('date_partitioned_table', INTERVAL '2 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 week');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 month');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 month 15 weeks 3 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 year 1 month 15 weeks 3 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE date_partitioned_table;
-- 2) retention threshold must be greater than compression threshold and
-- compression threshold must be greater than partition interval
-- With date partitioned table
CREATE TABLE ts_comp_date_partitioned_table(
    measureid integer,
    eventdatetime date,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '5 days');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '10 days', retention_threshold => INTERVAL '9 days');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', retention_threshold => INTERVAL '5 days');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
BEGIN;
    SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '10 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '10 days', retention_threshold => INTERVAL '15 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE ts_comp_date_partitioned_table;
-- With timestamptz partitioned table
CREATE TABLE ts_comp_tstz_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', compression_threshold => INTERVAL '1 hour');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', compression_threshold => INTERVAL '6 hours', retention_threshold => INTERVAL '5 hours');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', retention_threshold => INTERVAL '1 hour');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
BEGIN;
    SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', compression_threshold => INTERVAL '6 hours');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '90 minutes', compression_threshold => INTERVAL '180 minutes', retention_threshold => INTERVAL '360 minutes');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE ts_comp_tstz_partitioned_table;
-- Show that create_timeseries_table can be called to provide either pre make interval or start from parameters
CREATE TABLE param_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('param_test_partitioned_table', INTERVAL '90 minutes', premake_interval_count => 7, start_from => now());
ERROR:  either premake_interval_count or start_from should be provided
BEGIN;
    SELECT create_timeseries_table('param_test_partitioned_table', INTERVAL '90 minutes', premake_interval_count => 7);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('param_test_partitioned_table', INTERVAL '90 minutes', start_from => now());
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE param_test_partitioned_table;
-- Check pre make interval count and post make interval count
CREATE TABLE count_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
BEGIN;
    SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '1 minute', postmake_interval_count => 0, premake_interval_count => 0);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT count(*)
    FROM pg_catalog.time_partitions
    WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     1
(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '1 hour', postmake_interval_count => 0, premake_interval_count => 5);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT count(*)
    FROM pg_catalog.time_partitions
    WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     6
(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '2 weeks', postmake_interval_count => 5, premake_interval_count => 0);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT count(*)
    FROM pg_catalog.time_partitions
    WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     6
(1 row)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '2 months', postmake_interval_count => 3, premake_interval_count => 4);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT count(*)
    FROM pg_catalog.time_partitions
    WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     8
(1 row)

ROLLBACK;
DROP TABLE count_test_partitioned_table;
-- Check interval range values
CREATE TABLE range_check_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
BEGIN;
    SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 hour');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT
        date_trunc('hour',now()) - from_value::timestamptz as from_diff,
        date_trunc('hour', now()) - to_value::timestamptz as to_diff
    FROM pg_catalog.time_partitions
    ORDER BY 1;
   from_diff   |    to_diff
---------------------------------------------------------------------
 @ 7 hours ago | @ 8 hours ago
 @ 6 hours ago | @ 7 hours ago
 @ 5 hours ago | @ 6 hours ago
 @ 4 hours ago | @ 5 hours ago
 @ 3 hours ago | @ 4 hours ago
 @ 2 hours ago | @ 3 hours ago
 @ 1 hour ago  | @ 2 hours ago
 @ 0           | @ 1 hour ago
 @ 1 hour      | @ 0
 @ 2 hours     | @ 1 hour
 @ 3 hours     | @ 2 hours
 @ 4 hours     | @ 3 hours
 @ 5 hours     | @ 4 hours
 @ 6 hours     | @ 5 hours
 @ 7 hours     | @ 6 hours
(15 rows)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 day', postmake_interval_count => 5);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT partition,
        date_trunc('day',now()) - from_value::timestamptz as from_diff,
        date_trunc('day', now()) - to_value::timestamptz as to_diff
    FROM pg_catalog.time_partitions
    ORDER BY 1;
                   partition                    |  from_diff   |   to_diff
---------------------------------------------------------------------
 range_check_test_partitioned_table_p2021_08_25 | @ 7 days     | @ 6 days
 range_check_test_partitioned_table_p2021_08_26 | @ 6 days     | @ 5 days
 range_check_test_partitioned_table_p2021_08_27 | @ 5 days     | @ 4 days
 range_check_test_partitioned_table_p2021_08_28 | @ 4 days     | @ 3 days
 range_check_test_partitioned_table_p2021_08_29 | @ 3 days     | @ 2 days
 range_check_test_partitioned_table_p2021_08_30 | @ 2 days     | @ 1 day
 range_check_test_partitioned_table_p2021_08_31 | @ 1 day      | @ 0
 range_check_test_partitioned_table_p2021_09_01 | @ 0          | @ 1 day ago
 range_check_test_partitioned_table_p2021_09_02 | @ 1 day ago  | @ 2 days ago
 range_check_test_partitioned_table_p2021_09_03 | @ 2 days ago | @ 3 days ago
 range_check_test_partitioned_table_p2021_09_04 | @ 3 days ago | @ 4 days ago
 range_check_test_partitioned_table_p2021_09_05 | @ 4 days ago | @ 5 days ago
 range_check_test_partitioned_table_p2021_09_06 | @ 5 days ago | @ 6 days ago
(13 rows)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 week', premake_interval_count => 3);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT
        date_trunc('week',now()) - from_value::timestamptz as from_diff,
        date_trunc('week', now()) - to_value::timestamptz as to_diff
    FROM pg_catalog.time_partitions
    ORDER BY 1;
   from_diff   |    to_diff
---------------------------------------------------------------------
 @ 49 days ago | @ 56 days ago
 @ 42 days ago | @ 49 days ago
 @ 35 days ago | @ 42 days ago
 @ 28 days ago | @ 35 days ago
 @ 21 days ago | @ 28 days ago
 @ 14 days ago | @ 21 days ago
 @ 7 days ago  | @ 14 days ago
 @ 0           | @ 7 days ago
 @ 7 days      | @ 0
 @ 14 days     | @ 7 days
 @ 21 days     | @ 14 days
(11 rows)

ROLLBACK;
BEGIN;
    SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 week', start_from => now() - INTERVAL '4 weeks');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT
        date_trunc('week',now()) - from_value::timestamptz as from_diff,
        date_trunc('week', now()) - to_value::timestamptz as to_diff
    FROM pg_catalog.time_partitions
    ORDER BY 1;
   from_diff   |    to_diff
---------------------------------------------------------------------
 @ 49 days ago | @ 56 days ago
 @ 42 days ago | @ 49 days ago
 @ 35 days ago | @ 42 days ago
 @ 28 days ago | @ 35 days ago
 @ 21 days ago | @ 28 days ago
 @ 14 days ago | @ 21 days ago
 @ 7 days ago  | @ 14 days ago
 @ 0           | @ 7 days ago
 @ 7 days      | @ 0
 @ 14 days     | @ 7 days
 @ 21 days     | @ 14 days
 @ 28 days     | @ 21 days
(12 rows)

ROLLBACK;
-- Check drop table
CREATE TABLE drop_check_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('drop_check_test_partitioned_table', INTERVAL '2 hours');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT * FROM timeseries.tables;
           logicalrelid            | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
 drop_check_test_partitioned_table | @ 2 hours         |                     7 |                    7 |           |                      |
(1 row)

DROP TABLE drop_check_test_partitioned_table;
SELECT * FROM timeseries.tables;
 logicalrelid | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
(0 rows)

BEGIN;
    CREATE TABLE drop_check_test_partitioned_table(
        measureid integer,
        eventdatetime timestamp with time zone,
        measure_data integer) PARTITION BY RANGE(eventdatetime);
    SELECT create_timeseries_table('drop_check_test_partitioned_table', INTERVAL '2 hours');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

    SELECT * FROM timeseries.tables;
           logicalrelid            | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
 drop_check_test_partitioned_table | @ 2 hours         |                     7 |                    7 |           |                      |
(1 row)

    DROP TABLE drop_check_test_partitioned_table;
    SELECT * FROM timeseries.tables;
 logicalrelid | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
(0 rows)

COMMIT;
-- Check distributed partitioned table
CREATE TABLE distributed_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate);
SELECT create_distributed_table('distributed_partitioned_table', 'measureid');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_timeseries_table('distributed_partitioned_table', INTERVAL '1 day');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT * FROM timeseries.tables;
         logicalrelid          | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
 distributed_partitioned_table | @ 1 day           |                     7 |                    7 |           |                      |
(1 row)

-- We should have 512 shards since we have 15 partitions and 1 parent table
SELECT count(*)
FROM pg_dist_shard
WHERE logicalrelid::text LIKE 'distributed_partitioned_table%';
 count
---------------------------------------------------------------------
    64
(1 row)

DROP TABLE distributed_partitioned_table;
SELECT * FROM timeseries.tables;
 logicalrelid | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
(0 rows)

-- Show that partitioned reference tables are not supported
CREATE TABLE partitioned_reference_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate);
SELECT create_reference_table('partitioned_reference_table');
ERROR:  distributing partitioned tables in only supported for hash-distributed tables
DROP TABLE partitioned_reference_table;
