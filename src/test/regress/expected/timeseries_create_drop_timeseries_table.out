-- Show that create_timeseries_table only works for empty range partitioned tables
-- 1) Unpartitioned tables are not supported
CREATE TABLE unpartitioned_table(
    measureid integer,
    eventdatetime date,
    measure_data integer);
SELECT create_timeseries_table('unpartitioned_table', INTERVAL '1 day');
ERROR:  table must be partitioned by range to convert it to timeseries table
DROP TABLE unpartitioned_table;
-- 2) Nonempty tables are not supported
CREATE TABLE nonempty_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate);
CREATE TABLE nonempty_partitioned_table_2021_2100 PARTITION OF nonempty_partitioned_table FOR VALUES FROM ('2021-01-01') TO ('2100-01-01');
INSERT INTO nonempty_partitioned_table VALUES (1, now(), 1);
SELECT create_timeseries_table('nonempty_partitioned_table', INTERVAL '1 year');
ERROR:  table must be empty to convert it to timeseries table
DROP TABLE nonempty_partitioned_table;
-- 3) Table must be partitioned on single column
CREATE TABLE multicolumn_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate, measureid);
SELECT create_timeseries_table('multicolumn_partitioned_table', INTERVAL '1 year');
ERROR:  table must be partitioned by single column to convert it to timeseries table
DROP TABLE multicolumn_partitioned_table;
-- 4) Table must be partitioned by range
CREATE TABLE list_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY LIST(eventdate);
SELECT create_timeseries_table('list_partitioned_table', INTERVAL '1 year');
ERROR:  table must be partitioned by range to convert it to timeseries table
DROP TABLE list_partitioned_table;
CREATE TABLE hash_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY HASH(eventdate);
SELECT create_timeseries_table('hash_partitioned_table', INTERVAL '1 year');
ERROR:  table must be partitioned by range to convert it to timeseries table
DROP TABLE hash_partitioned_table;
-- Show that partition column type, partition interval and thresholds must align
-- 1) Partition interval must be multiple days for date partitioned tables
CREATE TABLE date_partitioned_table(
    measureid integer,
    eventdate date,
    measure_data integer) PARTITION BY RANGE(eventdate);
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '15 minutes');
ERROR:  partition interval for table partitioned on date must be multiple days
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '3 hours');
ERROR:  partition interval for table partitioned on date must be multiple days
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 day 15 minutes');
ERROR:  partition interval for table partitioned on date must be multiple days
BEGIN;
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '2 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 week');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 month');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 month 15 weeks 3 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('date_partitioned_table', INTERVAL '1 year 1 month 15 weeks 3 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE date_partitioned_table;
-- 2) retention threshold must be greater than compression threshold and
-- compresstion threshold must be greater than partition interval
-- With date partitioned table
CREATE TABLE ts_comp_date_partitioned_table(
    measureid integer,
    eventdatetime date,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '5 days');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '10 days', retention_threshold => INTERVAL '9 days');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', retention_threshold => INTERVAL '5 days');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
BEGIN;
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '10 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('ts_comp_date_partitioned_table', INTERVAL '1 week', compression_threshold => INTERVAL '10 days', retention_threshold => INTERVAL '15 days');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE ts_comp_date_partitioned_table;
-- With timestamptz partitioned table
CREATE TABLE ts_comp_tstz_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', compression_threshold => INTERVAL '1 hour');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', compression_threshold => INTERVAL '6 hours', retention_threshold => INTERVAL '5 hours');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', retention_threshold => INTERVAL '1 hour');
ERROR:  retention threshold must be greater than compression threshold and compression threshold must be greater than partition interval
BEGIN;
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '2 hours', compression_threshold => INTERVAL '6 hours');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('ts_comp_tstz_partitioned_table', INTERVAL '90 minutes', compression_threshold => INTERVAL '180 minutes', retention_threshold => INTERVAL '360 minutes');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE ts_comp_tstz_partitioned_table;
-- Show that create_timeseries_table can be called to provide either pre make interval or start from parameters
CREATE TABLE param_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('param_test_partitioned_table', INTERVAL '90 minutes', premake_interval_count => 7, start_from => now());
ERROR:  either premake_interval_count or start_from should be provided
BEGIN;
SELECT create_timeseries_table('param_test_partitioned_table', INTERVAL '90 minutes', premake_interval_count => 7);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('param_test_partitioned_table', INTERVAL '90 minutes', start_from => now());
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

ROLLBACK;
DROP TABLE param_test_partitioned_table;
-- Check pre make interval count and post make interval count
CREATE TABLE count_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
BEGIN;
SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '1 minute', postmake_interval_count => 0, premake_interval_count => 0);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT count(*)
FROM pg_catalog.time_partitions
WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     1
(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '1 hour', postmake_interval_count => 0, premake_interval_count => 5);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT count(*)
FROM pg_catalog.time_partitions
WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     6
(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '2 weeks', postmake_interval_count => 5, premake_interval_count => 0);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT count(*)
FROM pg_catalog.time_partitions
WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     6
(1 row)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('count_test_partitioned_table', INTERVAL '2 months', postmake_interval_count => 3, premake_interval_count => 4);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT count(*)
FROM pg_catalog.time_partitions
WHERE parent_table = 'count_test_partitioned_table'::regclass;
 count
---------------------------------------------------------------------
     8
(1 row)

ROLLBACK;
DROP TABLE count_test_partitioned_table;
-- Check interval range values
CREATE TABLE range_check_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
BEGIN;
SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 hour');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT partition,
       date_trunc('hour',now()) - from_value::timestamptz as from_diff,
       date_trunc('hour', now()) - to_value::timestamptz as to_diff
FROM pg_catalog.time_partitions
ORDER BY 1;
               partition               |   from_diff   |    to_diff
---------------------------------------------------------------------
 range_check_test_partitioned_table_0  | @ 7 hours     | @ 6 hours
 range_check_test_partitioned_table_1  | @ 6 hours     | @ 5 hours
 range_check_test_partitioned_table_2  | @ 5 hours     | @ 4 hours
 range_check_test_partitioned_table_3  | @ 4 hours     | @ 3 hours
 range_check_test_partitioned_table_4  | @ 3 hours     | @ 2 hours
 range_check_test_partitioned_table_5  | @ 2 hours     | @ 1 hour
 range_check_test_partitioned_table_6  | @ 1 hour      | @ 0
 range_check_test_partitioned_table_7  | @ 0           | @ 1 hour ago
 range_check_test_partitioned_table_8  | @ 1 hour ago  | @ 2 hours ago
 range_check_test_partitioned_table_9  | @ 2 hours ago | @ 3 hours ago
 range_check_test_partitioned_table_10 | @ 3 hours ago | @ 4 hours ago
 range_check_test_partitioned_table_11 | @ 4 hours ago | @ 5 hours ago
 range_check_test_partitioned_table_12 | @ 5 hours ago | @ 6 hours ago
 range_check_test_partitioned_table_13 | @ 6 hours ago | @ 7 hours ago
 range_check_test_partitioned_table_14 | @ 7 hours ago | @ 8 hours ago
(15 rows)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 day', postmake_interval_count => 5);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT partition,
       date_trunc('day',now()) - from_value::timestamptz as from_diff,
       date_trunc('day', now()) - to_value::timestamptz as to_diff
FROM pg_catalog.time_partitions
ORDER BY 1;
               partition               |  from_diff   |   to_diff
---------------------------------------------------------------------
 range_check_test_partitioned_table_0  | @ 7 days     | @ 6 days
 range_check_test_partitioned_table_1  | @ 6 days     | @ 5 days
 range_check_test_partitioned_table_2  | @ 5 days     | @ 4 days
 range_check_test_partitioned_table_3  | @ 4 days     | @ 3 days
 range_check_test_partitioned_table_4  | @ 3 days     | @ 2 days
 range_check_test_partitioned_table_5  | @ 2 days     | @ 1 day
 range_check_test_partitioned_table_6  | @ 1 day      | @ 0
 range_check_test_partitioned_table_7  | @ 0          | @ 1 day ago
 range_check_test_partitioned_table_8  | @ 1 day ago  | @ 2 days ago
 range_check_test_partitioned_table_9  | @ 2 days ago | @ 3 days ago
 range_check_test_partitioned_table_10 | @ 3 days ago | @ 4 days ago
 range_check_test_partitioned_table_11 | @ 4 days ago | @ 5 days ago
 range_check_test_partitioned_table_12 | @ 5 days ago | @ 6 days ago
(13 rows)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 week', premake_interval_count => 3);
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT partition,
       date_trunc('week',now()) - from_value::timestamptz as from_diff,
       date_trunc('week', now()) - to_value::timestamptz as to_diff
FROM pg_catalog.time_partitions
ORDER BY 1;
               partition               |   from_diff   |    to_diff
---------------------------------------------------------------------
 range_check_test_partitioned_table_0  | @ 21 days     | @ 14 days
 range_check_test_partitioned_table_1  | @ 14 days     | @ 7 days
 range_check_test_partitioned_table_2  | @ 7 days      | @ 0
 range_check_test_partitioned_table_3  | @ 0           | @ 7 days ago
 range_check_test_partitioned_table_4  | @ 7 days ago  | @ 14 days ago
 range_check_test_partitioned_table_5  | @ 14 days ago | @ 21 days ago
 range_check_test_partitioned_table_6  | @ 21 days ago | @ 28 days ago
 range_check_test_partitioned_table_7  | @ 28 days ago | @ 35 days ago
 range_check_test_partitioned_table_8  | @ 35 days ago | @ 42 days ago
 range_check_test_partitioned_table_9  | @ 42 days ago | @ 49 days ago
 range_check_test_partitioned_table_10 | @ 49 days ago | @ 56 days ago
(11 rows)

ROLLBACK;
BEGIN;
SELECT create_timeseries_table('range_check_test_partitioned_table', INTERVAL '1 week', start_from => now() - INTERVAL '4 weeks');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT partition,
       date_trunc('week',now()) - from_value::timestamptz as from_diff,
       date_trunc('week', now()) - to_value::timestamptz as to_diff
FROM pg_catalog.time_partitions
ORDER BY 1;
               partition               |   from_diff   |    to_diff
---------------------------------------------------------------------
 range_check_test_partitioned_table_0  | @ 28 days     | @ 21 days
 range_check_test_partitioned_table_1  | @ 21 days     | @ 14 days
 range_check_test_partitioned_table_2  | @ 14 days     | @ 7 days
 range_check_test_partitioned_table_3  | @ 7 days      | @ 0
 range_check_test_partitioned_table_4  | @ 0           | @ 7 days ago
 range_check_test_partitioned_table_5  | @ 7 days ago  | @ 14 days ago
 range_check_test_partitioned_table_6  | @ 14 days ago | @ 21 days ago
 range_check_test_partitioned_table_7  | @ 21 days ago | @ 28 days ago
 range_check_test_partitioned_table_8  | @ 28 days ago | @ 35 days ago
 range_check_test_partitioned_table_9  | @ 35 days ago | @ 42 days ago
 range_check_test_partitioned_table_10 | @ 42 days ago | @ 49 days ago
 range_check_test_partitioned_table_11 | @ 49 days ago | @ 56 days ago
(12 rows)

ROLLBACK;
-- Check drop table
CREATE TABLE drop_check_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('drop_check_test_partitioned_table', INTERVAL '2 hours');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT * FROM timeseries.tables;
           logicalrelid            | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
 drop_check_test_partitioned_table | @ 2 hours         |                     7 |                    7 |           |                      |
(1 row)

DROP TABLE drop_check_test_partitioned_table;
SELECT * FROM timeseries.tables;
 logicalrelid | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
(0 rows)

BEGIN;
CREATE TABLE drop_check_test_partitioned_table(
    measureid integer,
    eventdatetime timestamp with time zone,
    measure_data integer) PARTITION BY RANGE(eventdatetime);
SELECT create_timeseries_table('drop_check_test_partitioned_table', INTERVAL '2 hours');
 create_timeseries_table
---------------------------------------------------------------------

(1 row)

SELECT * FROM timeseries.tables;
           logicalrelid            | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
 drop_check_test_partitioned_table | @ 2 hours         |                     7 |                    7 |           |                      |
(1 row)

DROP TABLE drop_check_test_partitioned_table;
SELECT * FROM timeseries.tables;
 logicalrelid | partitioninterval | postmakeintervalcount | premakeintervalcount | startfrom | compressionthreshold | retentionthreshold
---------------------------------------------------------------------
(0 rows)

COMMIT;